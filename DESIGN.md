# napchat design implementation

Storage and authentication:
For authentication, I used Google Firebase Authentication; for storage, I used Google Firebase Realtime Database, completed with the Pyrebase4 python library wrapper. I used Firebase because it's a secure and free option where I can store the data on an already-established server and deploy the app online. I store user login information in Firebase Authentication, so login and register are completely authenticated by third party. I implemented the app this way to maximize security because I trust Google's security more than how I would implement it. The passwords are hashed, and the error message thrown by Firebase Authentication (regarding minimum password length, account email checking, etc) already ensures a minimum level of security. Whenever, the user makes an account, the account is created by the Pyrebase wrapper function and updated within firebase, given the account information the user submits via html POST. Whenever the user is authenticated and logged into the app, the user's session information is stored in Flask's session object, which puts a cookie on the website. This is very different from the temporary local file storage session type that the Finance pset uses; I used cookie and normal flask session to sustain session because heroku, the platform my app is deployed on, has temporal file storage, which would delete temp file sessions ever few seconds, but cookie-based session works fine. 

Besides login and register, the other functionalities of the app all use Firebase Realtime Database for data storage, which uses NoSQL (storing data as JSON). The data tables I have are: users, sleepTracker, history, session, friends, and pending. Every user child object stores a user's birthday, goal, name, and username. sleepTracker objects store username, date, hours. history stores objects with date, hours, start, end, timestamp, and username. session stores the secret_key needed for creating coockies in flask session. friends child objects stores user and friend. pending child objects store sender and receiver. Every databse can be queried using user's email account, which is stored in flask session after the user logs in. 

For the newnap() function, the newly logged sleep is retrieved from the HTML form via POST, processed to calculate the hours between start and end time, and the corresponding information relevant to each table are stored into history and sleepTracker tables. I maintained two separate tables because history keeps track the information of all logs as how they were entered, and sleepTacker keeps track of only the hours of a given day for a given user, which would be updated by the sleepTracker, so the user can logs nap time throughout a day and be given credit for the total sleep hours. The Nap Track index() ("/") reads the sleepTracker information from firebase, calculates streaks by counting the greatest number of consecutive dates (from today) recorded by the user where the hours of a date is greater or equal to the sleep goal recorded for the current user. For turning the dates yellow, the index function retrieves the hours for a whole month from the database, creates a list of booleans for that month (True for met sleep goal, else False), and passes that list to jinja, where it tests the list to output either either white or yellow components. 

For searching users in search_user(), the username or name is entered to return all objects in the users table where name or username matches one or more the existing accounts. I then process the database object returned by the query by creating a 2D list, where the users' name and email are added to the individual lists. I then removed all individual lists inside the 2d list where the searched user's account already exists in the current user's friends page (either existing or pending friends). For add_friend(), accept_request(), delete_person() functions that are called when the user press on different buttons, data are either added or deleted from the friends or pending tables, which are tables that store objects that have two usernames, denoting friendship and pending requests between sender and receiver. The friends function uses the friends and pending tables to output all of the friends and pending requests that the user has. The view button that can be used between friends is implemented the same way that index() POST request is, so it returns a friend's calendar view displaying all of the information that will display on a user's index page. 

The leaderboard() function receives data from sleepTracker table within the past week, for every single one of the user's friends and the user themselves. The data are processed and stored in a 2D list where each individual list includes a person's name, email, the total hours they logged in the past week, and the average hours of sleep per logged day. The 2D list is then sorted by the average_hours value within each list and then used in the html page to display a rank of the sleep schedule among a user and the user's friends. 